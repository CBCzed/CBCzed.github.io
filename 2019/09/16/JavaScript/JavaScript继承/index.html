<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="导读什么是继承呢？简单点说就是通过某种方式让一个对象可以访问到另一个对象中的属性和方法。JavaScript 本质上不能算是一门面向对象的编程语言，因为它对于封装、继承、多态这些面向对象语言的特点并没有在语言层面上提供原生的支持。但是，它引入了原型 (prototype) 的概念，可以让我们以另一种方式模仿类，并通过原型链的方式实现了父类子类之间共享属性的继承以及身份确认机制。">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript继承">
<meta property="og:url" content="http://yoursite.com/2019/09/16/JavaScript/JavaScript%E7%BB%A7%E6%89%BF/index.html">
<meta property="og:site_name" content="JavaScript修炼">
<meta property="og:description" content="导读什么是继承呢？简单点说就是通过某种方式让一个对象可以访问到另一个对象中的属性和方法。JavaScript 本质上不能算是一门面向对象的编程语言，因为它对于封装、继承、多态这些面向对象语言的特点并没有在语言层面上提供原生的支持。但是，它引入了原型 (prototype) 的概念，可以让我们以另一种方式模仿类，并通过原型链的方式实现了父类子类之间共享属性的继承以及身份确认机制。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-09-16T08:05:47.000Z">
<meta property="article:modified_time" content="2020-04-07T05:49:37.882Z">
<meta property="article:author" content="zed">
<meta property="article:tag" content="JavaScript">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2019/09/16/JavaScript/JavaScript%E7%BB%A7%E6%89%BF/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>JavaScript继承 | JavaScript修炼</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">JavaScript修炼</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/16/JavaScript/JavaScript%E7%BB%A7%E6%89%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="zed">
      <meta itemprop="description" content="欲望提升热忱，毅力磨平高山">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JavaScript修炼">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript继承
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-09-16 16:05:47" itemprop="dateCreated datePublished" datetime="2019-09-16T16:05:47+08:00">2019-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-04-07 13:49:37" itemprop="dateModified" datetime="2020-04-07T13:49:37+08:00">2020-04-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>什么是继承呢？简单点说就是通过某种方式让一个对象可以访问到另一个对象中的属性和方法。<br>JavaScript 本质上不能算是一门面向对象的编程语言，因为它对于封装、继承、多态这些面向对象语言的特点并没有在语言层面上提供原生的支持。但是，它引入了原型 (prototype) 的概念，可以让我们以另一种方式模仿类，并通过原型链的方式实现了父类子类之间共享属性的继承以及身份确认机制。</p>
<a id="more"></a>

<h2 id="继承的实现方式"><a href="#继承的实现方式" class="headerlink" title="继承的实现方式"></a>继承的实现方式</h2><h3 id="类式继承"><a href="#类式继承" class="headerlink" title="类式继承"></a>类式继承</h3><p>类式继承是将原型链作为实现继承的主要方法。其基本事项就是利用原型让一个引用类型继承另一个引用类型的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'superName'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给父类添加共有方法</span></span><br><span class="line">SuperClass.prototype.getSuperName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'subName'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承父类</span></span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass()</span><br><span class="line"><span class="comment">// 子类添加共有方法</span></span><br><span class="line">SubClass.prototype.getSubName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line">SubClass.prototype.constructor = SubClass</span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> SubClass()</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperName()) <span class="comment">// superName</span></span><br><span class="line"><span class="built_in">console</span>.log(instance.getSubName()) <span class="comment">// subName</span></span><br></pre></td></tr></table></figure>
<p>类式继承需要将第一个类的赋值给第二个类的原型，这是因为类的原型对象的作用就是为类的原型添加共有方法和属性，但类不能直接访问这些属性和方法，必须通过原型 prototype 访问。</p>
<p>类式继承的缺点是由于子类通过原型实例化了父类，所以父类中的共有属性是引用类型，那就会被子类所公用，若子类修改该引用类型，则会直接影响其他子类。另外一个点是，由于子类原型是从父类实例化而来的，所以子类原型的constructor就指向了父类，所以需要将其指向子类的构造函数。</p>
<h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><p>构造函数的继承的基本思想是在子类的构造函数内部调用超类的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.books = [<span class="string">'JavaScript'</span>, <span class="string">'css'</span>, <span class="string">'html'</span>]</span><br><span class="line">  <span class="keyword">this</span>.id = id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="keyword">this</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> SubClass(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> SubClass(<span class="number">2</span>)</span><br><span class="line">instance1.books.push(<span class="string">'Node'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.books)  <span class="comment">// ["JavaScript", "css", "html", "Node"]</span></span><br><span class="line"><span class="built_in">console</span>.log(instance1.id) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.books) <span class="comment">// ["JavaScript", "css", "html"]</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.id) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>如上代码，子类构造函数中通过 call 调用了父类的构造函数并改变了其作用环境，从而解决了类式继承实例之间引用类型的共享问题，但缺点也很明显，因为构造函数不涉及原型，所以父类的原型上的方法自然不会被子类继承，而子类若想要继承父类的方法，则父类必须将方法写在构造函数，而这样的做法导致每个实例都会单独创建一份代码，并不能实现代码上的共用。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承模式是将类式继承与构造函数继承的优点结合起来，其思路是使用原型链实现对原型属性和原型方法的继承，使用构造函数实现对父类属性的继承。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.books = [<span class="string">'JavaScript'</span>, <span class="string">'css'</span>, <span class="string">'html'</span>]</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span>(<span class="params">name, time</span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="keyword">this</span>, name)</span><br><span class="line">  <span class="keyword">this</span>.time = time</span><br><span class="line">&#125;</span><br><span class="line">SubClass.prototype = <span class="keyword">new</span> SuperClass()</span><br><span class="line">SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.time)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> SubClass(<span class="string">'zed'</span>, <span class="number">2019</span>)</span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> SubClass(<span class="string">'ada'</span>, <span class="number">2100</span>)</span><br><span class="line">instance1.books.push(<span class="string">'Node'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.books)  <span class="comment">// ["JavaScript", "css", "html", "Node"]</span></span><br><span class="line">instance1.getName() <span class="comment">// zed</span></span><br><span class="line">instance1.getTime() <span class="comment">// 2014</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(instance2.books) <span class="comment">// ["JavaScript", "css", "html"]</span></span><br><span class="line">instance2.getName() <span class="comment">// ada</span></span><br><span class="line">instance2.getTime() <span class="comment">// 2100</span></span><br></pre></td></tr></table></figure>
<p>组合继承的子类不是父类的实例，而是其原型才是父类的实例；且组合继承调用了两次父类的构造函数，使得父类构造函数中的方法和属性会产生两组，一组在子类实例上，一组在子类的原型上，只不过子类的实例覆盖了原型上的。</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>原型式继承式借助 prototype 可以基于已有的对象创建新的对象，同时不必创建新的自定义对象类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"> F.prototype = obj</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> book = &#123;</span><br><span class="line"> name: <span class="string">'js book'</span>,</span><br><span class="line"> alikeBook : [<span class="string">'css book'</span>, <span class="string">'html book'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> newBook = inheritObject(book)</span><br><span class="line">newBook.name = <span class="string">'zed'</span></span><br><span class="line">newBook.alikeBook.push(<span class="string">'flutter book'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> otherBook = inheritObject(book)</span><br><span class="line">otherBook.name = <span class="string">'ada'</span></span><br><span class="line">otherBook.alikeBook.push(<span class="string">'http book'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newBook.name) <span class="comment">// zed</span></span><br><span class="line"><span class="built_in">console</span>.log(newBook.alikeBook) <span class="comment">// ["css book", "html book", "flutter book", "http book"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(otherBook.name) <span class="comment">// ada</span></span><br><span class="line"><span class="built_in">console</span>.log(otherBook.alikeBook) <span class="comment">// ["css book", "html book", "flutter book", "http book"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(book.name) <span class="comment">// js book</span></span><br><span class="line"><span class="built_in">console</span>.log(book.alikeBook) <span class="comment">// ["css book", "html book", "flutter book", "http book"]</span></span><br></pre></td></tr></table></figure>
<p>原型式继承是是对类式继承的封装，所以类式继承的缺点在原型式继承中也存在，不过相对于类式继承，由于过渡函数F()没有内容，所以开销相对较小。Object.create() 的实现原理就类似与原型式继承，只不过 Object.create() 可以传递两个参数。</p>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>寄生式继承是对原型继承的二次封装，只不过继承的对象进行了拓展，这样新创建的对象不仅拥有父类的属性和方法，还可以添加新的属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"> F.prototype = obj</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createBook</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> o = inheritObject(obj) <span class="comment">// 或使用Object.create()代替 let o = Object.create(obj)﻿</span></span><br><span class="line">  o.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> book = &#123;</span><br><span class="line"> name: <span class="string">'js book'</span>,</span><br><span class="line"> alikeBook : [<span class="string">'css book'</span>, <span class="string">'html book'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newBook = createBook(book)</span><br><span class="line">newBook.name = <span class="string">'zed'</span></span><br><span class="line">newBook.alikeBook.push(<span class="string">'flutter book'</span>)</span><br><span class="line">newBook.getName() <span class="comment">// zed</span></span><br><span class="line"><span class="built_in">console</span>.log(newBook.alikeBook) <span class="comment">// ["css book", "html book", "flutter book"]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(book.name) <span class="comment">// js book</span></span><br><span class="line"><span class="built_in">console</span>.log(book.alikeBook) <span class="comment">//  ["css book", "html book", "flutter book"]</span></span><br></pre></td></tr></table></figure>
<h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><p>寄生式组合继承的基本思路是不必为了指定子类的原型而调用父类的构造函数，只需要的父类原型的一个副本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span> (<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="built_in">Object</span>.create(superClass.prototype)</span><br><span class="line">  <span class="comment">// 修正因为重写子类原型导致子类的constructor属性被修改</span></span><br><span class="line">  prototype.constructor = subClass</span><br><span class="line">  subClass.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperClass</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]</span><br><span class="line">&#125;</span><br><span class="line">SuperClass.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubClass</span> (<span class="params">name, time</span>) </span>&#123;</span><br><span class="line">  SuperClass.call(<span class="keyword">this</span>, name)</span><br><span class="line">  <span class="keyword">this</span>.time = time</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者直接使用Object.setPrototypeOf(SubClass.prototype, SuperClass.prototype)，这样就无需inheritPrototype函数</span></span><br><span class="line">inheritPrototype(SubClass, SuperClass) </span><br><span class="line">SubClass.prototype.getTime = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.time)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> SubClass(<span class="string">'zed'</span>, <span class="number">2019</span>)</span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> SubClass(<span class="string">'ada'</span>, <span class="number">2100</span>)</span><br><span class="line">instance1.colors.push(<span class="string">'pink'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(instance1.colors) <span class="comment">// ["red", "green", "blue", "pink"]</span></span><br><span class="line"><span class="built_in">console</span>.log(instance2.colors) <span class="comment">// ["red", "green", "blue"]</span></span><br><span class="line">instance2.getName() <span class="comment">// ada</span></span><br><span class="line">instance2.getTime() <span class="comment">// 2100</span></span><br></pre></td></tr></table></figure>
<p>ES6新增了一个方法<span class="en-text"> Object.setPrototypeOf() </span>可以直接创建关联，且不需要重新修正 constructor。</p>
<h3 id="ES6-class和extends"><a href="#ES6-class和extends" class="headerlink" title="ES6 class和extends"></a>ES6 class和extends</h3><p>ES6 新增了<span class="en-text"> class </span>和<span class="en-text"> extends </span>关键字，类的创建变得清晰，而不需要像 ES5 一样繁琐。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  getName () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (name, color) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">    <span class="keyword">this</span>.color = color</span><br><span class="line">  &#125;</span><br><span class="line">  getColor () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> Child(<span class="string">'zed'</span>, <span class="string">'red'</span>)</span><br><span class="line">instance.getName() <span class="comment">// zed</span></span><br><span class="line">instance.getColor() <span class="comment">// red</span></span><br></pre></td></tr></table></figure>
<p>使用 ES6 创建类时需要注意，子类构造函数中的<span class="en-text"> super </span>关键字表示父类的构造函数，用来新建父类的<span class="en-text"> this </span>对象；子类在构造函数中必须调用<span class="en-text"> super </span>方法，否则在创建实例时会报错，因为子类的<span class="en-text"> this </span>对象必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，若不调用则得不到子类的<span class="en-text"> this </span>对象。其次子类的构造函数必须在调用<span class="en-text"> super </span>方法后才可使用<span class="en-text"> this </span>。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/08/16/JavaScript/JavaScript%E5%8E%9F%E5%9E%8B%E5%8F%8A%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="prev" title="JavaScript原型及原型设计模式">
      <i class="fa fa-chevron-left"></i> JavaScript原型及原型设计模式
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/10/16/JavaScript/JavaScript%E4%B9%8Bnew%E4%B8%8Einstanceof%E7%9A%84%E5%8E%9F%E7%90%86/" rel="next" title="JavaScript之new与instanceof的原理">
      JavaScript之new与instanceof的原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#导读"><span class="nav-number">1.</span> <span class="nav-text">导读</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承的实现方式"><span class="nav-number">2.</span> <span class="nav-text">继承的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类式继承"><span class="nav-number">2.1.</span> <span class="nav-text">类式继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构造函数继承"><span class="nav-number">2.2.</span> <span class="nav-text">构造函数继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合继承"><span class="nav-number">2.3.</span> <span class="nav-text">组合继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原型式继承"><span class="nav-number">2.4.</span> <span class="nav-text">原型式继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄生式继承"><span class="nav-number">2.5.</span> <span class="nav-text">寄生式继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寄生组合式继承"><span class="nav-number">2.6.</span> <span class="nav-text">寄生组合式继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ES6-class和extends"><span class="nav-number">2.7.</span> <span class="nav-text">ES6 class和extends</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="zed"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">zed</p>
  <div class="site-description" itemprop="description">欲望提升热忱，毅力磨平高山</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/CBCzed" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;CBCzed" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zed</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
